"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WrapperClient = exports.FetchHttpClient = void 0;
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const url_1 = __importDefault(require("url"));
const defaultHttpAgent = new https_1.default.Agent({
    keepAlive: true,
});
class FetchHttpClient {
    constructor(httpAgent) {
        this.httpAgent = httpAgent || defaultHttpAgent;
    }
    /**
     * Wraps the http and https libraries in a fetch()-like interface
     * @param requestUrl
     * @param method HTTP Method (GET, POST, etc.)
     * @param headers HTTP Headers
     * @param  Request body
     */
    request(requestUrl, method, headers, body, timeoutMillis) {
        return new Promise((resolve, reject) => {
            if (timeoutMillis === 0) {
                reject(Error('Response timed out'));
                return;
            }
            const urlParams = url_1.default.parse(requestUrl);
            const options = Object.assign(Object.assign({}, urlParams), { method: method, headers: headers, body: body, agent: this.httpAgent, timeout: timeoutMillis });
            const protocol = urlParams.protocol === 'http:' ? http_1.default : https_1.default;
            const req = protocol.request(options);
            req.on('response', (res) => {
                res.setEncoding('utf-8');
                let responseBody = '';
                res.on('data', (chunk) => {
                    responseBody += chunk;
                });
                res.on('end', () => {
                    resolve({
                        status: res.statusCode,
                        body: responseBody,
                    });
                });
            });
            req.on('timeout', () => {
                req.destroy(Error('Socket connection timed out'));
            });
            req.on('error', (e) => {
                reject(e);
            });
            if (method !== 'GET' && body) {
                req.write(body);
            }
            req.end();
        });
    }
}
exports.FetchHttpClient = FetchHttpClient;
/**
 * Wrap the exposed HttpClient in a CoreClient implementation to work with
 * FlagApi and EvaluationApi.
 */
class WrapperClient {
    constructor(client) {
        this.client = client;
    }
    request(request) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.request(request.requestUrl, request.method, request.headers, null, request.timeoutMillis);
        });
    }
}
exports.WrapperClient = WrapperClient;
