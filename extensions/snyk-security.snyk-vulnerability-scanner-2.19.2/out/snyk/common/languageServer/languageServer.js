"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LanguageServer = void 0;
const lodash_1 = __importDefault(require("lodash"));
const rxjs_1 = require("rxjs");
const languageServer_1 = require("../constants/languageServer");
const settings_1 = require("../constants/settings");
const errorHandler_1 = require("../error/errorHandler");
const proxy_1 = require("../proxy");
const lsExecutable_1 = require("./lsExecutable");
const middleware_1 = require("./middleware");
const settings_2 = require("./settings");
class LanguageServer {
    constructor(user, configuration, languageClientAdapter, workspace, window, authenticationService, logger, downloadService) {
        this.user = user;
        this.configuration = configuration;
        this.languageClientAdapter = languageClientAdapter;
        this.workspace = workspace;
        this.window = window;
        this.authenticationService = authenticationService;
        this.logger = logger;
        this.downloadService = downloadService;
        this.cliReady$ = new rxjs_1.ReplaySubject(1);
        this.scan$ = new rxjs_1.Subject();
        this.downloadService = downloadService;
    }
    // Starts the language server and the client. LS will be downloaded if missing.
    // Returns a promise that resolves when the language server is ready to receive requests.
    async start() {
        var _a, _b, _c;
        // wait until Snyk LS is downloaded
        await (0, rxjs_1.firstValueFrom)(this.downloadService.downloadReady$);
        this.logger.info('Starting Snyk Language Server');
        // proxy settings
        const proxyOptions = await (0, proxy_1.getProxyOptions)(this.workspace, this.configuration, this.logger);
        const proxyEnvVariable = (0, proxy_1.getProxyEnvVariable)(proxyOptions);
        let processEnv = process.env;
        if (proxyEnvVariable) {
            processEnv = {
                ...processEnv,
                // eslint-disable-next-line camelcase
                https_proxy: proxyEnvVariable,
                // eslint-disable-next-line camelcase
                http_proxy: proxyEnvVariable,
            };
        }
        const lsBinaryPath = lsExecutable_1.LsExecutable.getPath(this.configuration.getSnykLanguageServerPath());
        // log level is set to info by default
        let logLevel = 'info';
        const additionalCliParameters = this.configuration.getAdditionalCliParameters();
        if (additionalCliParameters != null &&
            additionalCliParameters.length > 0 &&
            (additionalCliParameters.includes('-d') || additionalCliParameters.includes('--debug'))) {
            logLevel = 'debug';
        }
        logLevel = (_a = process.env.SNYK_LOG_LEVEL) !== null && _a !== void 0 ? _a : logLevel;
        const args = ['language-server', '-l', logLevel];
        this.logger.info(`Snyk Language Server - path: ${lsBinaryPath}`);
        this.logger.info(`Snyk Language Server - args: ${args}`);
        const serverOptions = {
            command: lsBinaryPath,
            args: args,
            options: {
                env: processEnv,
            },
        };
        // Options to control the language client
        const clientOptions = {
            documentSelector: [{ scheme: 'file', language: '' }],
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            initializationOptions: await this.getInitializationOptions(),
            synchronize: {
                configurationSection: settings_1.CONFIGURATION_IDENTIFIER,
            },
            middleware: new middleware_1.LanguageClientMiddleware(this.configuration, this.user),
            /**
             * We reuse the output channel here as it's not properly disposed of by the language client (vscode-languageclient@8.0.0-next.2)
             * See: https://github.com/microsoft/vscode-languageserver-node/blob/cdf4d6fdaefe329ce417621cf0f8b14e0b9bb39d/client/src/common/client.ts#L2789
             */
            outputChannel: (_c = (_b = this.client) === null || _b === void 0 ? void 0 : _b.outputChannel) !== null && _c !== void 0 ? _c : this.window.createOutputChannel(languageServer_1.SNYK_LANGUAGE_SERVER_NAME),
        };
        // Create the language client and start the client.
        this.client = this.languageClientAdapter.create('SnykLS', languageServer_1.SNYK_LANGUAGE_SERVER_NAME, serverOptions, clientOptions);
        try {
            // Start the client. This will also launch the server
            await this.client.start();
            this.logger.info('Snyk Language Server started');
            this.registerListeners(this.client);
        }
        catch (error) {
            return errorHandler_1.ErrorHandler.handle(error, this.logger, error instanceof Error ? error.message : 'An error occurred');
        }
    }
    registerListeners(client) {
        client.onNotification(languageServer_1.SNYK_HAS_AUTHENTICATED, ({ token }) => {
            this.authenticationService.updateToken(token).catch((error) => {
                errorHandler_1.ErrorHandler.handle(error, this.logger, error.message);
            });
        });
        client.onNotification(languageServer_1.SNYK_FOLDERCONFIG, ({ folderConfigs }) => {
            this.configuration.setFolderConfigs(folderConfigs).catch((error) => {
                errorHandler_1.ErrorHandler.handle(error, this.logger, error.message);
            });
        });
        client.onNotification(languageServer_1.SNYK_CLI_PATH, ({ cliPath }) => {
            if (!cliPath) {
                errorHandler_1.ErrorHandler.handle(new Error("CLI path wasn't provided by language server on $/snyk.isAvailableCli notification " + cliPath), this.logger, "CLI path wasn't provided by language server on notification");
                return;
            }
            const currentCliPath = this.configuration.getCliPath();
            if (currentCliPath != cliPath) {
                this.logger.info('Setting Snyk CLI path to: ' + cliPath);
                void this.configuration
                    .setCliPath(cliPath)
                    .then(() => {
                    this.cliReady$.next(cliPath);
                })
                    .catch((error) => {
                    errorHandler_1.ErrorHandler.handle(error, this.logger, error.message);
                });
            }
        });
        client.onNotification(languageServer_1.SNYK_ADD_TRUSTED_FOLDERS, ({ trustedFolders }) => {
            this.configuration.setTrustedFolders(trustedFolders).catch((error) => {
                errorHandler_1.ErrorHandler.handle(error, this.logger, error.message);
            });
        });
        client.onNotification(languageServer_1.SNYK_SCAN, (scan) => {
            this.logger.info(`${lodash_1.default.capitalize(scan.product)} scan for ${scan.folderPath}: ${scan.status}.`);
            this.scan$.next(scan);
        });
    }
    // Initialization options are not semantically equal to server settings, thus separated here
    // https://github.com/microsoft/language-server-protocol/issues/567
    async getInitializationOptions() {
        const settings = await settings_2.LanguageServerSettings.fromConfiguration(this.configuration, this.user);
        return settings;
    }
    showOutputChannel() {
        if (!this.client) {
            return;
        }
        this.client.outputChannel.show();
    }
    async stop() {
        var _a;
        this.logger.info('Stopping Snyk Language Server...');
        if (!this.client) {
            return Promise.resolve();
        }
        if ((_a = this.client) === null || _a === void 0 ? void 0 : _a.needsStop()) {
            await this.client.stop();
        }
        this.logger.info('Snyk Language Server stopped');
    }
}
exports.LanguageServer = LanguageServer;
//# sourceMappingURL=languageServer.js.map