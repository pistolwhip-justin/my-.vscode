/* eslint-disable @typescript-eslint/no-unsafe-argument */
/* eslint-disable @typescript-eslint/no-non-null-assertion */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/// <reference lib="dom" />
// This script will be run within the webview itself
// It cannot access the main VS Code APIs directly.
(function () {
    var _a, _b, _c;
    const vscode = acquireVsCodeApi();
    function sendMessage(message) {
        vscode.postMessage(message);
    }
    function navigateToIssue(position) {
        if (!suggestion) {
            return;
        }
        const message = {
            type: 'openLocal',
            args: {
                ...getSuggestionPosition(suggestion, position),
                suggestionUri: suggestion.filePath,
            },
        };
        sendMessage(message);
    }
    let suggestion = ((_a = vscode.getState()) === null || _a === void 0 ? void 0 : _a.suggestion) || null;
    function ignoreIssue(lineOnly) {
        if (!suggestion)
            return;
        const message = {
            type: 'ignoreIssue',
            args: {
                ...getSuggestionPosition(suggestion),
                message: suggestion.message,
                rule: suggestion.rule,
                id: suggestion.id,
                severity: suggestion.severity,
                lineOnly: lineOnly,
            },
        };
        sendMessage(message);
    }
    function getSuggestionPosition(suggestionParam, position) {
        var _a;
        return {
            uri: (_a = position === null || position === void 0 ? void 0 : position.file) !== null && _a !== void 0 ? _a : suggestionParam.filePath,
            rows: position ? position.rows : suggestionParam.rows,
            cols: position ? position.cols : suggestionParam.cols,
        };
    }
    const dataFlows = document.getElementsByClassName('data-flow-clickable-row');
    for (let i = 0; i < dataFlows.length; i++) {
        dataFlows[i].addEventListener('click', () => {
            const rows = [
                parseInt(dataFlows[i].getAttribute('start-line')),
                parseInt(dataFlows[i].getAttribute('end-line')),
            ];
            const cols = [
                parseInt(dataFlows[i].getAttribute('start-character')),
                parseInt(dataFlows[i].getAttribute('end-character')),
            ];
            const position = {
                file: dataFlows[i].getAttribute('file-path'),
                rows: rows,
                cols: cols,
            };
            navigateToIssue(position);
        });
    }
    (_b = document.getElementById('ignore-line-issue')) === null || _b === void 0 ? void 0 : _b.addEventListener('click', () => {
        ignoreIssue(true);
    });
    (_c = document.getElementById('ignore-file-issue')) === null || _c === void 0 ? void 0 : _c.addEventListener('click', () => {
        ignoreIssue(false);
    });
    document.getElementById('position-line').addEventListener('click', () => {
        navigateToIssue();
    });
    function toggleElement(element, toggle) {
        if (!element) {
            return;
        }
        if (toggle === 'show') {
            element.classList.remove('hidden');
        }
        else if (toggle === 'hide') {
            element.classList.add('hidden');
        }
        else {
            console.error('Unexpected toggle value', toggle);
        }
    }
    // different AI fix buttons
    const applyFixButton = document.getElementById('apply-fix');
    const retryGenerateFixButton = document.getElementById('retry-generate-fix');
    const generateAIFixButton = document.getElementById('generate-ai-fix');
    const ignoreContainerElements = document.getElementsByClassName('ignore-action-container');
    if (ignoreContainerElements) {
        ignoreContainerElements[0].style.display = (suggestion === null || suggestion === void 0 ? void 0 : suggestion.showInlineIgnoresButton) ? 'block' : 'none';
    }
    function generateAIFix() {
        if (!suggestion) {
            return;
        }
        toggleElement(generateAIFixButton, 'hide');
        toggleElement(fixLoadingIndicatorElem, 'show');
        const message = {
            type: 'getAutofixDiffs',
            args: { suggestion },
        };
        sendMessage(message);
    }
    function retryGenerateAIFix() {
        console.log('retrying generate AI Fix');
        toggleElement(fixWrapperElem, 'show');
        toggleElement(fixErrorSectionElem, 'hide');
        generateAIFix();
    }
    function applyFix() {
        if (!suggestion)
            return;
        const diffSuggestion = suggestion.diffs[diffSelectedIndex];
        const filePath = suggestion.filePath;
        const patch = diffSuggestion.unifiedDiffsPerFile[filePath];
        const fixId = diffSuggestion.fixId;
        const message = {
            type: 'applyGitDiff',
            args: { filePath, patch, fixId },
        };
        sendMessage(message);
    }
    generateAIFixButton === null || generateAIFixButton === void 0 ? void 0 : generateAIFixButton.addEventListener('click', generateAIFix);
    retryGenerateFixButton === null || retryGenerateFixButton === void 0 ? void 0 : retryGenerateFixButton.addEventListener('click', retryGenerateAIFix);
    applyFixButton === null || applyFixButton === void 0 ? void 0 : applyFixButton.addEventListener('click', applyFix);
    // different AI fix states
    const fixLoadingIndicatorElem = document.getElementById('fix-loading-indicator');
    const fixWrapperElem = document.getElementById('fix-wrapper');
    const fixSectionElem = document.getElementById('fixes-section');
    const fixErrorSectionElem = document.getElementById('fixes-error-section');
    // generated AI fix diffs
    const nextDiffElem = document.getElementById('next-diff');
    const previousDiffElem = document.getElementById('previous-diff');
    const diffSelectedIndexElem = document.getElementById('diff-counter');
    const diffTopElem = document.getElementById('diff-top');
    const diffElem = document.getElementById('diff');
    const noDiffsElem = document.getElementById('info-no-diffs');
    if (noDiffsElem) {
        noDiffsElem.innerText = "We couldn't determine any fixes for this issue.";
    }
    const diffNumElem = document.getElementById('diff-number');
    const diffNum2Elem = document.getElementById('diff-number2');
    let diffSelectedIndex = 0;
    function nextDiff() {
        if (!suggestion || !suggestion.diffs || diffSelectedIndex >= suggestion.diffs.length - 1)
            return;
        ++diffSelectedIndex;
        showCurrentDiff();
    }
    function previousDiff() {
        if (!suggestion || !suggestion.diffs || diffSelectedIndex <= 0)
            return;
        --diffSelectedIndex;
        showCurrentDiff();
    }
    function showCurrentDiff() {
        var _a, _b;
        if (!((_a = suggestion === null || suggestion === void 0 ? void 0 : suggestion.diffs) === null || _a === void 0 ? void 0 : _a.length)) {
            toggleElement(noDiffsElem, 'show');
            toggleElement(diffTopElem, 'hide');
            toggleElement(diffElem, 'hide');
            toggleElement(applyFixButton, 'hide');
            return;
        }
        if (!((_b = suggestion === null || suggestion === void 0 ? void 0 : suggestion.diffs) === null || _b === void 0 ? void 0 : _b.length) || diffSelectedIndex < 0 || diffSelectedIndex >= suggestion.diffs.length)
            return;
        toggleElement(noDiffsElem, 'hide');
        toggleElement(diffTopElem, 'show');
        toggleElement(diffElem, 'show');
        toggleElement(applyFixButton, 'show');
        diffNumElem.innerText = suggestion.diffs.length.toString();
        diffNum2Elem.innerText = suggestion.diffs.length.toString();
        diffSelectedIndexElem.innerText = (diffSelectedIndex + 1).toString();
        const diffSuggestion = suggestion.diffs[diffSelectedIndex];
        const filePath = suggestion.filePath;
        const patch = diffSuggestion.unifiedDiffsPerFile[filePath];
        // clear all elements
        while (diffElem.firstChild) {
            diffElem.removeChild(diffElem.firstChild);
        }
        diffElem.appendChild(generateDiffHtml(patch));
    }
    function generateDiffHtml(patch) {
        const codeLines = patch.split('\n');
        // the first two lines are the file names
        codeLines.shift();
        codeLines.shift();
        const diffHtml = document.createElement('div');
        let blockDiv = null;
        for (const line of codeLines) {
            if (line.startsWith('@@ ')) {
                blockDiv = document.createElement('div');
                blockDiv.className = 'example';
                if (blockDiv) {
                    diffHtml.appendChild(blockDiv);
                }
            }
            else {
                const lineDiv = document.createElement('div');
                lineDiv.className = 'example-line';
                if (line.startsWith('+')) {
                    lineDiv.classList.add('added');
                }
                else if (line.startsWith('-')) {
                    lineDiv.classList.add('removed');
                }
                const lineCode = document.createElement('code');
                // if line is empty, we need to fallback to ' '
                // to make sure it displays in the diff
                lineCode.innerText = line.slice(1, line.length) || ' ';
                lineDiv.appendChild(lineCode);
                blockDiv === null || blockDiv === void 0 ? void 0 : blockDiv.appendChild(lineDiv);
            }
        }
        return diffHtml;
    }
    nextDiffElem.addEventListener('click', nextDiff);
    previousDiffElem.addEventListener('click', previousDiff);
    window.addEventListener('message', event => {
        var _a;
        const message = event.data;
        switch (message.type) {
            case 'set': {
                suggestion = message.args;
                vscode.setState({ ...vscode.getState(), suggestion });
                break;
            }
            case 'get': {
                const newSuggestion = ((_a = vscode.getState()) === null || _a === void 0 ? void 0 : _a.suggestion) || {};
                if (newSuggestion != suggestion) {
                    suggestion = newSuggestion;
                }
                break;
            }
            case 'setAutofixDiffs': {
                if ((suggestion === null || suggestion === void 0 ? void 0 : suggestion.id) === message.args.suggestion.id) {
                    toggleElement(fixSectionElem, 'show');
                    toggleElement(fixLoadingIndicatorElem, 'hide');
                    toggleElement(fixWrapperElem, 'hide');
                    const { diffs } = message.args;
                    suggestion.diffs = diffs;
                    vscode.setState({ ...vscode.getState(), suggestion });
                    showCurrentDiff();
                }
                break;
            }
            case 'setAutofixError': {
                const errorSuggestion = message.args.suggestion;
                if (errorSuggestion.id != (suggestion === null || suggestion === void 0 ? void 0 : suggestion.id)) {
                    console.log('Got an error for a previously generated suggestion: ignoring');
                    break;
                }
                toggleElement(fixWrapperElem, 'hide');
                toggleElement(fixErrorSectionElem, 'show');
            }
        }
    });
})();
//# sourceMappingURL=codeSuggestionWebviewScriptLS.js.map