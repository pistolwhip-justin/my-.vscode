"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IssueTreeProvider = void 0;
const types_1 = require("../../common/commands/types");
const commands_1 = require("../../common/constants/commands");
const issueTreeProvider_1 = require("../../common/views/issueTreeProvider");
const analysis_1 = require("../messages/analysis");
const issueUtils_1 = require("../utils/issueUtils");
const treeNode_1 = require("../../common/views/treeNode");
class IssueTreeProvider extends issueTreeProvider_1.ProductIssueTreeProvider {
    constructor(contextService, codeService, configuration, languages, isSecurityType, folderConfigs) {
        super(contextService, codeService, configuration, languages, folderConfigs);
        this.contextService = contextService;
        this.codeService = codeService;
        this.configuration = configuration;
        this.languages = languages;
        this.isSecurityType = isSecurityType;
        this.folderConfigs = folderConfigs;
        this.getRunTestMessage = () => analysis_1.messages.runTest;
    }
    shouldShowTree() {
        return this.contextService.shouldShowCodeAnalysis;
    }
    filterIssues(issues) {
        return issues.filter(i => i.additionalData.isSecurityType == this.isSecurityType);
    }
    // The title in the tree is taken from the title for vulnerabilities and from the message for quality rules
    getIssueTitle(issue) {
        const fixIcon = issue.additionalData.hasAIFix ? '⚡️' : '';
        const issueTitle = issue.additionalData.isSecurityType
            ? issue.title.split(':')[0]
            : issue.additionalData.message.split('.')[0];
        let prefixIgnored = '';
        if (issue.isIgnored) {
            prefixIgnored = '[ Ignored ] ';
        }
        return fixIcon + prefixIgnored + issueTitle;
    }
    getIssueRange(issue) {
        return issueUtils_1.IssueUtils.createVsCodeRange(issue.additionalData, this.languages);
    }
    getOpenIssueCommand(issue, folderPath, filePath) {
        return {
            command: commands_1.SNYK_OPEN_ISSUE_COMMAND,
            title: '',
            arguments: [
                {
                    issueType: types_1.OpenCommandIssueType.CodeIssue,
                    issue: {
                        id: issue.id,
                        folderPath,
                        filePath,
                        range: this.getIssueRange(issue),
                    },
                },
            ],
        };
    }
    isFixableIssue(issue) {
        return issue.additionalData.hasAIFix;
    }
    getFixableIssuesNode(fixableIssueCount) {
        return new treeNode_1.TreeNode({
            text: this.getAIFixableIssuesText(fixableIssueCount),
        });
    }
    getAIFixableIssuesText(issuesCount) {
        return issuesCount > 0
            ? `⚡️ ${issuesCount} ${issuesCount === 1 ? 'issue' : 'issues'} can be fixed by Snyk DeepCode AI`
            : 'There are no issues fixable by Snyk DeepCode AI';
    }
}
exports.IssueTreeProvider = IssueTreeProvider;
//# sourceMappingURL=issueTreeProvider.js.map