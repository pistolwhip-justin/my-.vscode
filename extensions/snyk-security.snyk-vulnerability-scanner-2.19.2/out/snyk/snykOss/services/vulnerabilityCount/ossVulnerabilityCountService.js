"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OssVulnerabilityCountService = void 0;
const parsing_1 = require("../../../common/parsing");
const moduleParserProvider_1 = require("../../../common/services/moduleParserProvider");
const types_1 = require("../../../common/types");
const analysis_1 = require("../../../snykCode/constants/analysis");
const importedModule_1 = require("./importedModule");
const vulnerabilityCountEmitter_1 = require("./vulnerabilityCountEmitter");
class OssVulnerabilityCountService {
    constructor(workspace, window, languages, vulnerabilityCountProvider, ossService, logger, editorDecorator, configuration) {
        this.workspace = workspace;
        this.window = window;
        this.languages = languages;
        this.vulnerabilityCountProvider = vulnerabilityCountProvider;
        this.ossService = ossService;
        this.logger = logger;
        this.editorDecorator = editorDecorator;
        this.configuration = configuration;
        this.disposables = [];
        this.fileEmitters = new Map();
    }
    activate() {
        this.disposables.push((this.diagnostics = this.languages.createDiagnosticCollection(analysis_1.DIAGNOSTICS_OSS_COLLECTION_NAME)), this.workspace.onDidChangeTextDocument((ev) => {
            if (ev === null || ev === void 0 ? void 0 : ev.contentChanges.length) {
                // TODO: this feature is buggy if implemented; reset decorations instead as a compromise
                // this.processFile(ev.document);
                this.editorDecorator.resetDecorations(ev.document.fileName);
            }
        }), this.window.onDidChangeActiveTextEditor((ev) => {
            if (ev) {
                this.processFile(ev.document);
            }
        }));
        // Subscribe to OSS scan finished updates
        this.ossScanFinishedSubscription = this.ossService.newResultAvailable$.subscribe(() => this.processActiveEditor());
        return true;
    }
    processActiveEditor() {
        const activeEditor = this.window.getActiveTextEditor();
        if (activeEditor) {
            this.processFile(activeEditor.document);
        }
    }
    dispose() {
        while (this.disposables.length) {
            const disposable = this.disposables.pop();
            if (disposable) {
                disposable.dispose();
            }
        }
        for (const emitter of this.fileEmitters.values()) {
            emitter.removeAllListeners();
        }
        this.ossScanFinishedSubscription.unsubscribe();
    }
    processFile(document) {
        if (!document) {
            return false;
        }
        const { fileName, languageId } = document;
        const supportedLanguage = (0, parsing_1.getSupportedLanguage)(fileName, languageId);
        if (supportedLanguage === null || !this.shouldProcessFile(fileName, supportedLanguage)) {
            return false;
        }
        let emitter = this.fileEmitters.get(fileName);
        if (emitter) {
            emitter.removeAllListeners();
            this.editorDecorator.resetDecorations(fileName);
        }
        else {
            emitter = new vulnerabilityCountEmitter_1.VulnerabilityCountEmitter();
            this.fileEmitters.set(fileName, emitter);
        }
        emitter.on(vulnerabilityCountEmitter_1.VulnerabilityCountEvents.Error, e => {
            this.logger.error(`Error counting module issues: ${e}`);
            this.editorDecorator.resetDecorations(fileName);
        });
        emitter.on(vulnerabilityCountEmitter_1.VulnerabilityCountEvents.Start, (modules) => {
            this.editorDecorator.setScanStartDecorations(fileName, modules);
        });
        emitter.on(vulnerabilityCountEmitter_1.VulnerabilityCountEvents.Scanned, (vulnerabilityCount) => {
            this.editorDecorator.setScannedDecoration(vulnerabilityCount, true);
        });
        emitter.on(vulnerabilityCountEmitter_1.VulnerabilityCountEvents.Done, (modules) => {
            this.editorDecorator.setScanDoneDecorations(fileName, modules);
            // TODO: delete this and related code if we move HTML diagnostics to Language Server
            // Update diagnostics only for HTML files; for other files, diagnostics are provided by Language Server
            if ((0, parsing_1.getSupportedLanguage)(fileName, languageId) === types_1.Language.HTML) {
                this.updateDiagnostics(document, modules);
            }
        });
        // Start
        void this.getImportedModules(fileName, document.getText(), supportedLanguage, emitter);
        return true;
    }
    updateDiagnostics(document, modules) {
        if (!this.diagnostics) {
            return;
        }
        const diagnostics = [];
        for (const module of modules) {
            if (!module.hasCount || !module.range) {
                continue;
            }
            const diagnosticMessage = this.getDiagnosticMessage(module);
            if (!diagnosticMessage.length) {
                continue;
            }
            const range = this.languages.createRange(module.range.start.line - 1, module.range.start.column, module.range.end.line - 1, module.range.end.column);
            const diagnostic = this.languages.createDiagnostic(range, diagnosticMessage, 1); // Warning severity
            diagnostics.push({
                ...diagnostic,
                source: analysis_1.DIAGNOSTICS_OSS_COLLECTION_NAME,
                code: module.mostSevereVulnerabilityId,
            });
        }
        this.diagnostics.set(document.uri, diagnostics);
    }
    shouldProcessFile(fileName, language) {
        if ([types_1.Language.TypeScript, types_1.Language.JavaScript, types_1.Language.PJSON].includes(language)) {
            const ossResult = this.vulnerabilityCountProvider.getResultArray();
            if (!ossResult) {
                return false;
            }
            for (const fileResult of ossResult) {
                if (this.vulnerabilityCountProvider.isFilePartOfOssTest(fileName, fileResult)) {
                    return true;
                }
            }
            return false;
        }
        return true;
    }
    async getImportedModules(fileName, content, language, emitter) {
        try {
            const modules = this.getModules(fileName, content, language).filter(parsing_1.isValidModuleName);
            emitter.startScanning(modules);
            const vulnerabilityCountPromises = modules.map(module => this.vulnerabilityCountProvider.getVulnerabilityCount(fileName, module, language, emitter));
            const vulnerabilityCount = await Promise.all(vulnerabilityCountPromises);
            emitter.done(vulnerabilityCount);
        }
        catch (e) {
            emitter.error(e);
        }
    }
    getModules(fileName, source, language) {
        const parser = moduleParserProvider_1.ModuleParserProvider.getInstance(language, this.logger, this.configuration);
        if (!parser) {
            return [];
        }
        return parser.getModules(fileName, source, language);
    }
    getDiagnosticMessage(module) {
        if (!module.count) {
            return '';
        }
        let message = `Dependency ${module.name}${module.version ? `@${module.version}` : ''} has `;
        message += this.getSeverityCountMessage([
            importedModule_1.ModuleVulnerabilityCountSeverity.Critical,
            importedModule_1.ModuleVulnerabilityCountSeverity.High,
            importedModule_1.ModuleVulnerabilityCountSeverity.Medium,
            importedModule_1.ModuleVulnerabilityCountSeverity.Low,
        ], module);
        return message;
    }
    getSeverityCountMessage(severities, module) {
        if (!module.severityCounts) {
            return module.count ? module.count : '';
        }
        const content = [];
        for (const severity of severities) {
            if (module.severityCounts[severity] > 0) {
                content.push(`${module.severityCounts[severity]} ${severity}`);
            }
        }
        return content.join(', ');
    }
}
exports.OssVulnerabilityCountService = OssVulnerabilityCountService;
//# sourceMappingURL=ossVulnerabilityCountService.js.map