"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const vscode_1 = require("vscode");
const types_1 = require("../../common/commands/types");
const instance_1 = require("../../common/configuration/instance");
const commands_1 = require("../../common/constants/commands");
const views_1 = require("../../common/constants/views");
const types_2 = require("../../common/languageServer/types");
const issueTreeProvider_1 = require("../../common/views/issueTreeProvider");
const treeNode_1 = require("../../common/views/treeNode");
const messages_1 = require("../constants/messages");
const ossIssueCommandHelper_1 = require("./ossIssueCommandHelper");
class OssIssueTreeProvider extends issueTreeProvider_1.ProductIssueTreeProvider {
    constructor(viewManagerService, contextService, ossService, configuration, languages, folderConfigs) {
        super(contextService, ossService, configuration, languages, folderConfigs);
        this.viewManagerService = viewManagerService;
        this.contextService = contextService;
        this.ossService = ossService;
        this.configuration = configuration;
        this.languages = languages;
        this.folderConfigs = folderConfigs;
        this.onDidChangeTreeData = this.viewManagerService.refreshOssViewEmitter.event;
        this.getRunTestMessage = () => messages_1.messages.treeView.runTest;
        this.getIssueTitle = (issue) => issue.title;
        this.getIssueRange = () => undefined;
    }
    getRootChildren() {
        var _a;
        if (!((_a = instance_1.configuration.getFeaturesConfiguration()) === null || _a === void 0 ? void 0 : _a.ossEnabled)) {
            return [
                new treeNode_1.TreeNode({
                    text: views_1.SNYK_ANALYSIS_STATUS.OSS_DISABLED,
                }),
            ];
        }
        return super.getRootChildren();
    }
    getResultNodes() {
        const nodes = [];
        for (const result of this.productService.result.entries()) {
            const folderPath = result[0];
            const folderResult = result[1];
            const uri = vscode_1.Uri.file(folderPath);
            const shortFolderPath = uri.path.split('/');
            const folderName = shortFolderPath.pop() || uri.path;
            let folderVulnCount = 0;
            if (folderResult instanceof Error && folderResult.message === types_2.LsErrorMessage.repositoryInvalidError) {
                nodes.push(this.getFaultyRepositoryErrorTreeNode(folderName, folderResult.toString()));
                continue;
            }
            if (folderResult instanceof Error) {
                nodes.push(this.getErrorEncounteredTreeNode(folderName));
                continue;
            }
            const folderSeverityCounts = this.initSeverityCounts();
            const fileNodes = [];
            const fileVulns = lodash_1.default.groupBy(folderResult, v => v.filePath);
            for (const file in fileVulns) {
                const fileIssues = fileVulns[file];
                const uri = vscode_1.Uri.file(file);
                const filePath = uri.path.split('/');
                const filename = filePath.pop() || uri.path;
                const dir = filePath.pop();
                const fileSeverityCounts = this.initSeverityCounts();
                const uniqueIssues = fileIssues.filter((issue, index, self) => index === self.findIndex(t => t.id === issue.id));
                const filteredIssues = this.filterIssues(uniqueIssues);
                const vulnerabilityNodes = this.filterVisibleIssues(filteredIssues).map((issue) => {
                    fileSeverityCounts[issue.severity] += 1;
                    folderVulnCount++;
                    return new treeNode_1.TreeNode({
                        text: `${issue.additionalData.packageName}@${issue.additionalData.version} - ${issue.title}`,
                        icon: issueTreeProvider_1.ProductIssueTreeProvider.getSeverityIcon(issue.severity),
                        internal: {
                            severity: issueTreeProvider_1.ProductIssueTreeProvider.getSeverityComparatorIndex(issue.severity),
                        },
                        command: this.getOpenIssueCommand(issue, folderPath, '', filteredIssues),
                    });
                });
                if (vulnerabilityNodes.length === 0) {
                    continue;
                }
                vulnerabilityNodes.sort(this.compareNodes);
                const fileSeverity = issueTreeProvider_1.ProductIssueTreeProvider.getHighestSeverity(fileSeverityCounts);
                folderSeverityCounts[fileSeverity] += 1;
                // append file node
                const fileNode = new treeNode_1.TreeNode({
                    text: filename,
                    description: this.getIssueDescriptionText(dir, vulnerabilityNodes.length),
                    icon: issueTreeProvider_1.ProductIssueTreeProvider.getSeverityIcon(fileSeverity),
                    children: vulnerabilityNodes,
                    internal: {
                        nIssues: vulnerabilityNodes.length,
                        severity: issueTreeProvider_1.ProductIssueTreeProvider.getSeverityComparatorIndex(fileSeverity),
                    },
                });
                fileNodes.push(fileNode);
            }
            fileNodes.sort(this.compareNodes);
            const folderSeverity = issueTreeProvider_1.ProductIssueTreeProvider.getHighestSeverity(folderSeverityCounts);
            const baseBranchNode = this.getBaseBranch(uri.fsPath);
            if (folderVulnCount == 0) {
                this.addBaseBranchNode(baseBranchNode, nodes);
                continue;
            }
            // flatten results if single workspace folder
            if (this.productService.result.size === 1) {
                this.addBaseBranchNode(baseBranchNode, nodes);
                nodes.push(...fileNodes);
            }
            else {
                const folderNode = new treeNode_1.TreeNode({
                    text: folderName,
                    description: this.getIssueDescriptionText(folderName, folderVulnCount),
                    icon: issueTreeProvider_1.ProductIssueTreeProvider.getSeverityIcon(folderSeverity),
                    children: fileNodes,
                    internal: {
                        nIssues: folderVulnCount,
                        severity: issueTreeProvider_1.ProductIssueTreeProvider.getSeverityComparatorIndex(folderSeverity),
                    },
                });
                this.addBaseBranchNode(baseBranchNode, fileNodes);
                nodes.push(folderNode);
            }
        }
        return nodes;
    }
    shouldShowTree() {
        return this.contextService.shouldShowOssAnalysis;
    }
    getIssueDescriptionText(dir, issueCount) {
        return `${dir} - ${issueCount} ${issueCount === 1 ? 'vulnerability' : 'vulnerabilities'}`;
    }
    getIssueFoundText(nIssues, _) {
        if (!nIssues) {
            return 'âœ… Congrats! No issues found!';
        }
        return `Snyk found ${nIssues} issue${nIssues === 1 ? '' : 's'}`;
    }
    filterIssues(issues) {
        return issues.filter(vuln => {
            switch (vuln.severity.toLowerCase()) {
                case types_2.IssueSeverity.Critical:
                    return this.configuration.severityFilter.critical;
                case types_2.IssueSeverity.High:
                    return this.configuration.severityFilter.high;
                case types_2.IssueSeverity.Medium:
                    return this.configuration.severityFilter.medium;
                case types_2.IssueSeverity.Low:
                    return this.configuration.severityFilter.low;
                default:
                    return true;
            }
        });
    }
    getOpenIssueCommand(issue, folderPath, _filePath, filteredIssues) {
        return {
            command: commands_1.SNYK_OPEN_ISSUE_COMMAND,
            title: '',
            arguments: [
                {
                    issueType: types_1.OpenCommandIssueType.OssVulnerability,
                    issue: (0, ossIssueCommandHelper_1.getOssIssueCommandArg)(issue, folderPath, filteredIssues),
                },
            ],
        };
    }
}
exports.default = OssIssueTreeProvider;
//# sourceMappingURL=ossVulnerabilityTreeProvider.js.map